#!/usr/bin/env python3
import argparse
import subprocess
import sys
import time
from pathlib import Path

# add src to path so we can import our modules
sys.path.insert(0, str(Path(__file__).parent / "src"))

import daemon_manager as dm


# ##################################################################
# command ps
# lists all configured processes with their current status
def command_ps(args: argparse.Namespace) -> int:
    processes = dm.list_processes()
    if not processes:
        print("No processes configured")
        return 0

    rows = []
    for name, info in sorted(processes.items()):
        pid = info["pid"]
        pid_str = str(pid) if pid is not None else "dead"
        port = info.get("port")
        port_str = str(port) if port is not None else "-"
        rows.append((name, pid_str, port_str))

    name_width = max(len(row[0]) for row in rows)
    pid_width = max(len(row[1]) for row in rows)
    port_width = max(len(row[2]) for row in rows)

    for name, pid_str, port_str in rows:
        print(f"{name.ljust(name_width)}  {pid_str.rjust(pid_width)}  {port_str.rjust(port_width)}")
    return 0


# ##################################################################
# command start
# starts a configured process by name
def command_start(args: argparse.Namespace) -> int:
    name = args.name
    try:
        pid = dm.start_process(name)
        print(f"Started {name} with pid {pid}")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command stop
# stops a running process by name
def command_stop(args: argparse.Namespace) -> int:
    name = args.name
    try:
        dm.stop_process(name)
        print(f"Stopped {name}")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command restart
# restarts a process by stopping and starting it
def command_restart(args: argparse.Namespace) -> int:
    name = args.name
    try:
        # stop if running
        pid = dm.get_process_status(name)
        if pid is not None:
            dm.stop_process(name)
            print(f"Stopped {name}")

            # wait for process to completely die
            if not dm.wait_for_process_death(pid, timeout_seconds=10):
                print(f"Warning: process {name} did not die within timeout, forcing kill")
                try:
                    import os
                    import signal
                    os.kill(pid, signal.SIGKILL)
                    # wait a bit more for SIGKILL to take effect
                    dm.wait_for_process_death(pid, timeout_seconds=2)
                except OSError:
                    pass

        # start
        pid = dm.start_process(name)
        print(f"Started {name} with pid {pid}")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command add
# adds a new process to config and starts it immediately
def command_add(args: argparse.Namespace) -> int:
    name = args.name
    command = " ".join(args.command)
    try:
        workdir = args.workdir
        if workdir is None:
            workdir = str(Path.cwd())
        dm.add_process(name, command, port=args.port, workdir=workdir)
        print(f"Added {name}")
        pid = dm.start_process(name)
        print(f"Started {name} with pid {pid}")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command remove
# removes a process from config and stops it if running
def command_remove(args: argparse.Namespace) -> int:
    name = args.name
    try:
        dm.remove_process(name)
        print(f"Removed {name}")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command show
# displays the command line for a configured process
def command_show(args: argparse.Namespace) -> int:
    name = args.name
    try:
        command = dm.get_process_command(name)
        print(f"{name}: {command}")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command log
# shows the latest log path or tails it for a process
def command_log(args: argparse.Namespace) -> int:
    name = args.name
    if not name:
        print("Error: process name is required")
        return 1
    try:
        log_path = dm.get_latest_log_path(name)
        if log_path is None:
            print(f"No logs found for {name}")
            return 1
        if args.name_only:
            print(log_path)
            return 0
        if args.tail:
            result = subprocess.run(["tail", "-f", str(log_path)])
            return result.returncode
        result = subprocess.run(["cat", str(log_path)])
        return result.returncode
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command start all
# starts all configured processes that are not currently running
def command_start_all(args: argparse.Namespace) -> int:
    dm.start_all_processes()
    print("Started all configured processes")
    return 0


# ##################################################################
# command watch
# continuously monitors and restarts dead processes with exponential backoff
def command_watch(args: argparse.Namespace) -> int:
    print("Watching processes for automatic restart...")
    try:
        while True:
            dm.watch_and_restart_processes()
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nStopped watching")
        return 0


# ##################################################################
# command shutdown
# stops all running processes without marking them explicitly stopped
def command_shutdown(args: argparse.Namespace) -> int:
    try:
        dm.shutdown_all_processes(timeout_seconds=args.timeout)
        print("Stopped all running processes")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command install
# installs both wrapper script and launch agent plist file
def command_install(args: argparse.Namespace) -> int:
    try:
        # install wrapper script
        dm.install_wrapper_script()
        wrapper_path = dm.get_wrapper_script_path()
        print(f"Installed wrapper script to {wrapper_path}")

        # install launch agent
        dm.install_launch_agent()
        launch_agent_path = dm.get_launch_agent_path()
        print(f"Installed launch agent to {launch_agent_path}")
        print("The auto daemon will now start automatically at login")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command uninstall
# uninstalls both launch agent and wrapper script
def command_uninstall(args: argparse.Namespace) -> int:
    try:
        # uninstall launch agent
        dm.uninstall_launch_agent()
        print("Uninstalled launch agent")

        # uninstall wrapper script
        dm.uninstall_wrapper_script()
        print("Uninstalled wrapper script")
        print("The auto daemon will no longer start automatically at login")
        return 0
    except Exception as err:
        print(f"Error: {err}")
        return 1


# ##################################################################
# command verify
# runs the full verification suite (pytest)
def command_verify(args: argparse.Namespace) -> int:
    result = subprocess.run([sys.executable, "-m", "pytest"])
    return result.returncode


# ##################################################################
# main
# parses arguments and dispatches to the appropriate command handler
def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(
        prog="auto",
        description="Manage daemon processes"
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    # ps command
    ps_parser = subparsers.add_parser("ps", help="List all processes with status")
    ps_parser.set_defaults(func=command_ps)

    # start command
    start_parser = subparsers.add_parser("start", help="Start a process")
    start_parser.add_argument("name", help="Process name")
    start_parser.set_defaults(func=command_start)

    # stop command
    stop_parser = subparsers.add_parser("stop", help="Stop a process")
    stop_parser.add_argument("name", help="Process name")
    stop_parser.set_defaults(func=command_stop)

    # restart command
    restart_parser = subparsers.add_parser("restart", help="Restart a process")
    restart_parser.add_argument("name", help="Process name")
    restart_parser.set_defaults(func=command_restart)

    # add command
    add_parser = subparsers.add_parser("add", help="Add a new process and start it")
    add_parser.add_argument("name", help="Process name")
    add_parser.add_argument("command", nargs="+", help="Command to run")
    add_parser.add_argument("--port", type=int, help="Optional port number")
    add_parser.add_argument("--workdir", help="Working directory to run the process in")
    add_parser.set_defaults(func=command_add)

    # remove command
    remove_parser = subparsers.add_parser("remove", help="Remove a process")
    remove_parser.add_argument("name", help="Process name")
    remove_parser.set_defaults(func=command_remove)

    # show command
    show_parser = subparsers.add_parser("show", help="Show process command")
    show_parser.add_argument("name", help="Process name")
    show_parser.set_defaults(func=command_show)

    # log command
    log_parser = subparsers.add_parser("log", help="Show or follow the latest log for a process")
    log_parser.add_argument("name", help="Process name")
    log_parser.add_argument("--tail", action="store_true", help="Tail the latest log")
    log_parser.add_argument("--name", dest="name_only", action="store_true", help="Print latest log path only")
    log_parser.set_defaults(func=command_log)

    # start-all command (used by LaunchAgent)
    start_all_parser = subparsers.add_parser("start-all", help="Start all configured processes")
    start_all_parser.set_defaults(func=command_start_all)

    # watch command
    watch_parser = subparsers.add_parser("watch", help="Monitor and restart dead processes")
    watch_parser.set_defaults(func=command_watch)

    # shutdown command
    shutdown_parser = subparsers.add_parser("shutdown", help="Stop all running processes without marking them stopped")
    shutdown_parser.add_argument("--timeout", type=int, default=10, help="Seconds to wait for each process to exit")
    shutdown_parser.set_defaults(func=command_shutdown)

    # install command
    install_parser = subparsers.add_parser("install", help="Install launch agent for automatic startup at login")
    install_parser.set_defaults(func=command_install)

    # uninstall command
    uninstall_parser = subparsers.add_parser("uninstall", help="Uninstall launch agent")
    uninstall_parser.set_defaults(func=command_uninstall)

    # verify command
    verify_parser = subparsers.add_parser("verify", help="Run verification suite")
    verify_parser.set_defaults(func=command_verify)

    args = parser.parse_args(argv)
    return args.func(args)


# ##################################################################
# standard python pattern for dispatching main
if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
